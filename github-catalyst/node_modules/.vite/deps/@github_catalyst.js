import "./chunk-RSJERJUL.js";

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/bind.js
var controllers = /* @__PURE__ */ new WeakSet();
function bind(controller2) {
  controllers.add(controller2);
  if (controller2.shadowRoot)
    bindShadow(controller2.shadowRoot);
  bindElements(controller2);
  listenForBind(controller2.ownerDocument);
}
function bindShadow(root) {
  bindElements(root);
  listenForBind(root);
}
var observers = /* @__PURE__ */ new WeakMap();
function listenForBind(el = document) {
  if (observers.has(el))
    return observers.get(el);
  let closed = false;
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes" && mutation.target instanceof Element) {
        bindActions(mutation.target);
      } else if (mutation.type === "childList" && mutation.addedNodes.length) {
        for (const node of mutation.addedNodes) {
          if (node instanceof Element) {
            bindElements(node);
          }
        }
      }
    }
  });
  observer.observe(el, { childList: true, subtree: true, attributeFilter: ["data-action"] });
  const subscription = {
    get closed() {
      return closed;
    },
    unsubscribe() {
      closed = true;
      observers.delete(el);
      observer.disconnect();
    }
  };
  observers.set(el, subscription);
  return subscription;
}
function bindElements(root) {
  for (const el of root.querySelectorAll("[data-action]")) {
    bindActions(el);
  }
  if (root instanceof Element && root.hasAttribute("data-action")) {
    bindActions(root);
  }
}
function handleEvent(event) {
  const el = event.currentTarget;
  for (const binding of bindings(el)) {
    if (event.type === binding.type) {
      const controller2 = el.closest(binding.tag);
      if (controllers.has(controller2) && typeof controller2[binding.method] === "function") {
        controller2[binding.method](event);
      }
      const root = el.getRootNode();
      if (root instanceof ShadowRoot && controllers.has(root.host) && root.host.matches(binding.tag)) {
        const shadowController = root.host;
        if (typeof shadowController[binding.method] === "function") {
          shadowController[binding.method](event);
        }
      }
    }
  }
}
function* bindings(el) {
  for (const action of (el.getAttribute("data-action") || "").trim().split(/\s+/)) {
    const eventSep = action.lastIndexOf(":");
    const methodSep = Math.max(0, action.lastIndexOf("#")) || action.length;
    yield {
      type: action.slice(0, eventSep),
      tag: action.slice(eventSep + 1, methodSep),
      method: action.slice(methodSep + 1) || "handleEvent"
    };
  }
}
function bindActions(el) {
  for (const binding of bindings(el)) {
    el.addEventListener(binding.type, handleEvent);
  }
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/dasherize.js
var dasherize = (str) => String(typeof str === "symbol" ? str.description : str).replace(/([A-Z]($|[a-z]))/g, "-$1").replace(/--/g, "-").replace(/^-|-$/, "").toLowerCase();
var mustDasherize = (str, type = "property") => {
  const dashed = dasherize(str);
  if (!dashed.includes("-")) {
    throw new DOMException(`${type}: ${String(str)} is not a valid ${type} name`, "SyntaxError");
  }
  return dashed;
};

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/register.js
function register(classObject) {
  const name = dasherize(classObject.name).replace(/-element$/, "");
  try {
    window.customElements.define(name, classObject);
    window[classObject.name] = customElements.get(name);
  } catch (e) {
    if (!(e instanceof DOMException && e.name === "NotSupportedError"))
      throw e;
  }
  return classObject;
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/findtarget.js
function findTarget(controller2, name) {
  const tag = controller2.tagName.toLowerCase();
  if (controller2.shadowRoot) {
    for (const el of controller2.shadowRoot.querySelectorAll(`[data-target~="${tag}.${name}"]`)) {
      if (!el.closest(tag))
        return el;
    }
  }
  for (const el of controller2.querySelectorAll(`[data-target~="${tag}.${name}"]`)) {
    if (el.closest(tag) === controller2)
      return el;
  }
}
function findTargets(controller2, name) {
  const tag = controller2.tagName.toLowerCase();
  const targets2 = [];
  if (controller2.shadowRoot) {
    for (const el of controller2.shadowRoot.querySelectorAll(`[data-targets~="${tag}.${name}"]`)) {
      if (!el.closest(tag))
        targets2.push(el);
    }
  }
  for (const el of controller2.querySelectorAll(`[data-targets~="${tag}.${name}"]`)) {
    if (el.closest(tag) === controller2)
      targets2.push(el);
  }
  return targets2;
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/auto-shadow-root.js
function autoShadowRoot(element) {
  for (const template of element.querySelectorAll("template[data-shadowroot]")) {
    if (template.parentElement === element) {
      element.attachShadow({
        mode: template.getAttribute("data-shadowroot") === "closed" ? "closed" : "open"
      }).append(template.content.cloneNode(true));
    }
  }
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/attr.js
var attrKey = "attr";
function attr(proto, key) {
  meta(proto, attrKey).add(key);
}
var initialized = /* @__PURE__ */ new WeakSet();
function initializeAttrs(instance, names) {
  var _a, _b;
  if (initialized.has(instance))
    return;
  initialized.add(instance);
  const proto = Object.getPrototypeOf(instance);
  const prefix = (_b = (_a = proto == null ? void 0 : proto.constructor) == null ? void 0 : _a.attrPrefix) != null ? _b : "data-";
  if (!names)
    names = meta(proto, attrKey);
  for (const key of names) {
    const value = instance[key];
    const name = mustDasherize(`${prefix}${key}`);
    let descriptor = {
      configurable: true,
      get() {
        return this.getAttribute(name) || "";
      },
      set(newValue) {
        this.setAttribute(name, newValue || "");
      }
    };
    if (typeof value === "number") {
      descriptor = {
        configurable: true,
        get() {
          return Number(this.getAttribute(name) || 0);
        },
        set(newValue) {
          this.setAttribute(name, newValue);
        }
      };
    } else if (typeof value === "boolean") {
      descriptor = {
        configurable: true,
        get() {
          return this.hasAttribute(name);
        },
        set(newValue) {
          this.toggleAttribute(name, newValue);
        }
      };
    }
    Object.defineProperty(instance, key, descriptor);
    if (key in instance && !instance.hasAttribute(name)) {
      descriptor.set.call(instance, value);
    }
  }
}
function defineObservedAttributes(classObject) {
  var _a;
  let observed = classObject.observedAttributes || [];
  const prefix = (_a = classObject.attrPrefix) != null ? _a : "data-";
  const attrToAttributeName = (name) => mustDasherize(`${prefix}${name}`);
  Object.defineProperty(classObject, "observedAttributes", {
    configurable: true,
    get() {
      return [...meta(classObject.prototype, attrKey)].map(attrToAttributeName).concat(observed);
    },
    set(attributes) {
      observed = attributes;
    }
  });
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/core.js
var symbol = Symbol.for("catalyst");
var CatalystDelegate = class {
  constructor(classObject) {
    const delegate = this;
    const connectedCallback = classObject.prototype.connectedCallback;
    classObject.prototype.connectedCallback = function() {
      delegate.connectedCallback(this, connectedCallback);
    };
    const disconnectedCallback = classObject.prototype.disconnectedCallback;
    classObject.prototype.disconnectedCallback = function() {
      delegate.disconnectedCallback(this, disconnectedCallback);
    };
    const attributeChangedCallback = classObject.prototype.attributeChangedCallback;
    classObject.prototype.attributeChangedCallback = function(name, oldValue, newValue) {
      delegate.attributeChangedCallback(this, name, oldValue, newValue, attributeChangedCallback);
    };
    let observedAttributes = classObject.observedAttributes || [];
    Object.defineProperty(classObject, "observedAttributes", {
      configurable: true,
      get() {
        return delegate.observedAttributes(this, observedAttributes);
      },
      set(attributes) {
        observedAttributes = attributes;
      }
    });
    defineObservedAttributes(classObject);
    register(classObject);
  }
  observedAttributes(instance, observedAttributes) {
    return observedAttributes;
  }
  connectedCallback(instance, connectedCallback) {
    instance.toggleAttribute("data-catalyst", true);
    customElements.upgrade(instance);
    autoShadowRoot(instance);
    initializeAttrs(instance);
    bind(instance);
    connectedCallback == null ? void 0 : connectedCallback.call(instance);
    if (instance.shadowRoot)
      bindShadow(instance.shadowRoot);
  }
  disconnectedCallback(element, disconnectedCallback) {
    disconnectedCallback == null ? void 0 : disconnectedCallback.call(element);
  }
  attributeChangedCallback(instance, name, oldValue, newValue, attributeChangedCallback) {
    initializeAttrs(instance);
    if (name !== "data-catalyst" && attributeChangedCallback) {
      attributeChangedCallback.call(instance, name, oldValue, newValue);
    }
  }
};
function meta(proto, name) {
  if (!Object.prototype.hasOwnProperty.call(proto, symbol)) {
    const parent = proto[symbol];
    const map2 = proto[symbol] = /* @__PURE__ */ new Map();
    if (parent) {
      for (const [key, value] of parent) {
        map2.set(key, new Set(value));
      }
    }
  }
  const map = proto[symbol];
  if (!map.has(name))
    map.set(name, /* @__PURE__ */ new Set());
  return map.get(name);
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/target.js
function target(proto, key) {
  meta(proto, "target").add(key);
  Object.defineProperty(proto, key, {
    configurable: true,
    get() {
      return findTarget(this, key);
    }
  });
}
function targets(proto, key) {
  meta(proto, "targets").add(key);
  Object.defineProperty(proto, key, {
    configurable: true,
    get() {
      return findTargets(this, key);
    }
  });
}

// node_modules/.pnpm/@github+catalyst@1.5.0/node_modules/@github/catalyst/lib/controller.js
function controller(classObject) {
  new CatalystDelegate(classObject);
}
export {
  attr,
  autoShadowRoot,
  bind,
  controller,
  defineObservedAttributes,
  findTarget,
  findTargets,
  initializeAttrs,
  listenForBind,
  register,
  target,
  targets
};
//# sourceMappingURL=@github_catalyst.js.map
