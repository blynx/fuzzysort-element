import "./chunk-RSJERJUL.js";

// node_modules/.pnpm/@github+mini-throttle@2.1.0/node_modules/@github/mini-throttle/dist/index.js
function throttle(callback, wait = 0, { start = true, middle = true, once = false } = {}) {
  let last = 0;
  let timer;
  let cancelled = false;
  function fn(...args) {
    if (cancelled)
      return;
    const delta = Date.now() - last;
    last = Date.now();
    if (start) {
      start = false;
      callback.apply(this, args);
      if (once)
        fn.cancel();
    } else if (middle && delta < wait || !middle) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        last = Date.now();
        callback.apply(this, args);
        if (once)
          fn.cancel();
      }, !middle ? wait : wait - delta);
    }
  }
  fn.cancel = () => {
    clearTimeout(timer);
    cancelled = true;
  };
  return fn;
}
function debounce(callback, wait = 0, { start = false, middle = false, once = false } = {}) {
  return throttle(callback, wait, { start, middle, once });
}

// node_modules/.pnpm/@github+mini-throttle@2.1.0/node_modules/@github/mini-throttle/dist/decorators.js
function throttle2(wait = 0, opts = {}) {
  return (proto, name, descriptor) => {
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new Error("debounce can only decorate functions");
    }
    const fn = descriptor.value;
    descriptor.value = throttle(fn, wait, opts);
    Object.defineProperty(proto, name, descriptor);
  };
}
function debounce2(wait = 0, opts = {}) {
  return (proto, name, descriptor) => {
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new Error("debounce can only decorate functions");
    }
    const fn = descriptor.value;
    descriptor.value = debounce(fn, wait, opts);
    Object.defineProperty(proto, name, descriptor);
  };
}
export {
  debounce2 as debounce,
  throttle2 as throttle
};
//# sourceMappingURL=@github_mini-throttle_decorators.js.map
